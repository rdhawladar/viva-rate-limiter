{
  "tasks": [
    {
      "id": 1,
      "title": "Ensure AI-Blocked Messages are Not Sent",
      "description": "The AI is correctly identifying messages to be blocked, but the application is still sending these messages to the recipient. This defeats the purpose of the AI blocking feature.",
      "details": "Review the message sending pipeline. The check for `CuriAI.shouldBlock()` must happen before the message is dispatched to the server/recipient. Ensure the client-side logic correctly interprets the AI's blocking decision and halts the sending process. Pseudocode: `function onSendMessage(message) { const isBlocked = CuriAI.shouldBlock(message); if (isBlocked) { return; } sendMessageToServer(message); }`",
      "testStrategy": "1. As a user, type a message that should be blocked by the AI. 2. Confirm the AI flags it for blocking. 3. Verify the message does NOT appear in the recipient's chat window. 4. Verify the sender sees a 'Message Blocked' notification.",
      "priority": "high",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Locate and Isolate the Message Dispatch Logic",
          "description": "Identify the exact function or code block in the message sending pipeline that dispatches the message to the server. Refactor this logic into a distinct, callable function (e.g., `dispatchMessageToServer(message)`) if it's not already, to clearly separate the dispatch action from the pre-send checks.",
          "dependencies": [],
          "details": "Search the codebase for the network request responsible for sending a message. This is likely within a component method like `handleSendMessage` or `submitForm`. The goal is to have a clear entry point for the sending logic and a clear function to call or *not* call based on the AI's decision. No functional change should occur in this step, only code organization.",
          "status": "pending",
          "testStrategy": "Run existing regression tests for message sending to ensure the refactoring did not break the happy path. Manually send a message in a development environment to confirm it's still delivered correctly."
        },
        {
          "id": 2,
          "title": "Integrate `CuriAI.shouldBlock()` Check Before Dispatch",
          "description": "In the primary message sending handler (identified in subtask 2), call `CuriAI.shouldBlock(message)` before the newly isolated `dispatchMessageToServer` function is called. Store the boolean result of the AI check in a variable.",
          "dependencies": [],
          "details": "Within the `onSendMessage(message)` function (or equivalent), add the following logic: `const isBlocked = await CuriAI.shouldBlock(message);`. Ensure this call happens before `dispatchMessageToServer(message)`. The `dispatchMessageToServer` call will be made conditional in the next step.",
          "status": "pending",
          "testStrategy": "Use a debugger or console logs to verify that `CuriAI.shouldBlock()` is called with the correct message content and that the `isBlocked` variable correctly reflects the (mocked or real) return value."
        },
        {
          "id": 3,
          "title": "Implement Conditional Dispatch and Halt for Blocked Messages",
          "description": "Using the `isBlocked` variable from the previous step, create a conditional block. If `isBlocked` is true, halt the execution by returning from the function, preventing the `dispatchMessageToServer` call. If false, allow the `dispatchMessageToServer` call to proceed as normal.",
          "dependencies": [],
          "details": "Wrap the existing dispatch logic in an if/else statement: `if (isBlocked) { // Logic for subtask 5 will go here return; } else { dispatchMessageToServer(message); }`. For now, the `if` block can simply contain a `console.log('Message blocked by AI')` and a `return` statement.",
          "status": "pending",
          "testStrategy": "Manually test by forcing `CuriAI.shouldBlock()` to return `true`. Verify that the network request to send the message is NOT made. Then, force it to return `false` and verify the message is sent."
        },
        {
          "id": 4,
          "title": "Provide User Feedback for Blocked Messages",
          "description": "When a message is blocked, the user must be notified. Implement UI feedback inside the `if (isBlocked)` block. This could be a toast notification, an inline error message near the text input, or temporarily disabling the send button.",
          "dependencies": [],
          "details": "Choose a user-friendly notification mechanism. For example, using a toast library: `toast.error('Your message could not be sent as it violates our content policy.');`. Update the component's state to reflect the blocked status, which can be used to show an error message in the UI.",
          "status": "pending",
          "testStrategy": "Visually inspect the UI after triggering the blocking condition. Confirm that the chosen feedback (toast, error message, etc.) appears correctly and is non-disruptive. Check that the UI returns to a normal state after the user dismisses the notification or types a new message."
        },
        {
          "id": 5,
          "title": "Write Unit Tests with a Mocked AI Service",
          "description": "Create unit/integration tests for the message sending handler. Use a mocking library (like Jest or Vitest mocks) to control the return value of `CuriAI.shouldBlock()` and verify the application's behavior in both blocked and allowed scenarios.",
          "dependencies": [],
          "details": "Create a mock for the `CuriAI` module. Write at least two test cases: 1. Mock `CuriAI.shouldBlock` to return `true`. Assert that `dispatchMessageToServer` is NOT called and the UI feedback function IS called. 2. Mock `CuriAI.shouldBlock` to return `false`. Assert that `dispatchMessageToServer` IS called and no UI error feedback is triggered.",
          "status": "pending",
          "testStrategy": "Run the test suite and ensure all assertions pass. Check test coverage reports to confirm that the new conditional logic in the message sending handler is fully covered by these tests."
        }
      ]
    },
    {
      "id": 2,
      "title": "Enable AI to Access Public Space Message History",
      "description": "The AI is currently unaware of messages sent by participants in the public space, leading to incorrect or out-of-context responses and actions.",
      "details": "The AI's context needs to be enriched with the message history from the public space. When invoking the AI for a decision or response, pass the recent message history of the relevant public space as part of the input prompt or context object. Pseudocode: `function getAIResponse(current_prompt) { const public_messages = getPublicSpaceHistory(); const context = { ...current_prompt.context, history: public_messages }; const enriched_prompt = { ...current_prompt, context }; return CuriAI.generate(enriched_prompt); }`",
      "testStrategy": "1. A participant sends several messages in the public space. 2. Invoke an AI feature that relies on conversation context. 3. Verify the AI's response or action correctly reflects the content of the messages previously sent in the public space.",
      "priority": "high",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement a Service to Fetch Public Space Message History",
          "description": "Create a new function or method within the application's service layer to retrieve recent messages from a specific public space. This will be the foundational component for accessing conversation history.",
          "dependencies": [],
          "details": "This function should accept a `spaceId` and a `limit` (number of messages) as parameters. It needs to query the primary data store (e.g., database, document store) for messages belonging to the given `spaceId`, ordered chronologically (descending by timestamp). The function should return a structured array of message objects, for example: `[{ authorId: string, content: string, timestamp: Date }]`.",
          "status": "pending",
          "testStrategy": "Write unit tests to verify the function correctly retrieves messages for a known `spaceId`. Test edge cases such as an invalid `spaceId`, a space with zero messages, and ensuring the `limit` parameter is respected."
        },
        {
          "id": 2,
          "title": "Create a Utility Function to Format Message History for the AI",
          "description": "Develop a dedicated utility function that transforms the raw array of message objects from the history service into a clean, single string format suitable for injection into the AI's prompt.",
          "dependencies": [
            1
          ],
          "details": "This function will take the array of message objects as input. It should iterate through the messages and format each one into a human-readable line, such as `\"User <authorId>: <content>\"`. All lines should be concatenated into a single string, separated by newlines, to represent the conversation flow. This ensures the AI receives the context in a simple, digestible format.",
          "status": "pending",
          "testStrategy": "Unit test the formatting function with various inputs: an empty message array, a single message, and multiple messages. Assert that the output string matches the expected format exactly."
        },
        {
          "id": 3,
          "title": "Integrate History Retrieval and Formatting into AI Invocation Flow",
          "description": "Modify the core logic that prepares and sends requests to the AI. This subtask involves calling the new history service and the formatting utility at the correct point in the execution flow.",
          "dependencies": [
            1,
            2
          ],
          "details": "In the function responsible for calling the AI (e.g., `getAIResponse`), first call the history service created in subtask 1 to get the message data. Then, pass this data to the formatting utility from subtask 2 to get the formatted history string. Store this string in a variable for the next step.",
          "status": "pending",
          "testStrategy": "In the unit tests for the AI invocation logic, mock the history service and the formatting utility. Verify that both are called with the correct parameters and that the formatted string is correctly stored."
        },
        {
          "id": 4,
          "title": "Update AI Prompt to Include Formatted Message History",
          "description": "Adjust the construction of the AI's final prompt or context object to include the formatted message history string. This directly provides the conversation context to the AI model.",
          "dependencies": [
            3
          ],
          "details": "Locate the code where the AI's prompt/context object is assembled. Following the pseudocode example, enrich the context object by adding a `history` key containing the formatted string. The system prompt should also be updated to instruct the AI on how to use this history, e.g., \"Use the recent conversation history below to provide a context-aware response.\"",
          "status": "pending",
          "testStrategy": "Unit test the prompt construction logic. Provide a mock formatted history string and assert that the final prompt object passed to the AI model correctly includes this history in the expected structure."
        },
        {
          "id": 5,
          "title": "Add Configuration for History Length and Perform End-to-End Verification",
          "description": "Introduce a configuration setting for the number of messages to fetch and conduct an end-to-end test to confirm the AI's behavior is improved by the new context.",
          "dependencies": [
            4
          ],
          "details": "Create a new environment variable or configuration parameter, such as `AI_HISTORY_MESSAGE_LIMIT`, to control the `limit` passed to the history service. This allows for easy tuning without code changes. Once implemented, perform manual testing in a staging environment by creating a conversation with specific details and then querying the AI to see if its response correctly uses information from that conversation.",
          "status": "pending",
          "testStrategy": "Perform manual end-to-end testing in a staging environment. Set up a public space with a known message history. Ask the AI a question whose answer depends on the history. Verify the AI's response is contextually correct. An automated integration test could also be created to simulate this entire flow."
        }
      ]
    },
    {
      "id": 3,
      "title": "Differentiate User Messages from AI Responses in UI",
      "description": "Messages received from other users are being incorrectly displayed as if they were generated by Curi AI. This causes significant user confusion.",
      "details": "Review the message rendering component. Each message object received from the backend/WebSocket should have a `sender_type` or `author_id` field. The UI component must use this field to apply the correct styling (e.g., user message bubble vs. AI response bubble). Pseudocode: `function MessageBubble({ message }) { if (message.sender_type === 'ai') { return <CuriAIResponse content={message.text} />; } else { return <UserMessage content={message.text} author={message.author_name} />; } }`",
      "testStrategy": "1. In a room with another user and Curi AI. 2. Receive a message from the other human user. 3. Verify the message is displayed with the user's name and profile picture, distinct from an AI response. 4. Receive a message from the AI. 5. Verify the message is clearly marked as coming from Curi AI.",
      "priority": "high",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Investigate and Document Message Object Schema",
          "description": "Before implementing UI changes, we must confirm the exact structure of the message objects received from the backend/WebSocket. Identify the definitive field (e.g., `sender_type`, `author_id`, `is_ai`) and its possible values that distinguish between a user and the Curi AI.",
          "dependencies": [],
          "details": "Use browser developer tools to inspect the WebSocket frames or network responses in the chat interface. Capture a few sample message objects from both users and the AI. Document the key-value pair used for differentiation in the task ticket for future reference.",
          "status": "pending",
          "testStrategy": "Manually trigger and inspect messages from both a test user and the AI to confirm the data structure is consistent and document the findings."
        },
        {
          "id": 2,
          "title": "Add Conditional Logic to Message Rendering Component",
          "description": "Modify the primary message rendering component (e.g., `MessageBubble.jsx`) to include conditional logic that checks the sender identification field discovered in the previous subtask. This logic will determine which type of message bubble to render.",
          "dependencies": [],
          "details": "Implement an `if/else` block or a ternary operator based on the `sender_type` (or equivalent field). The logic should route the message data to two different presentational sub-components, one for user messages and one for AI messages. For now, these can be simple placeholders. Example: `if (message.sender_type === 'ai') { return <AIResponse ... />; } else { return <UserMessage ... />; }`.",
          "status": "pending",
          "testStrategy": "Use a mock message object in a Storybook or local test environment to verify that the correct conditional branch is executed for both AI and user message types. The UI will not look correct yet, but the component structure should be right."
        },
        {
          "id": 3,
          "title": "Implement Styles for User Message Bubbles",
          "description": "Create the specific CSS styles or a styled-component for messages sent by a human user. This style should visually distinguish user messages from AI responses, for example, by using a different background color and right-alignment.",
          "dependencies": [],
          "details": "Create a new CSS module (e.g., `UserMessage.module.css`) or a styled-component file. Define styles for the message container, including properties like `background-color: #E1F5FE;`, `align-self: flex-end;`, `border-radius`, etc. This component will receive props like `content` and `author`.",
          "status": "pending",
          "testStrategy": "Render the new user message component in isolation (e.g., in Storybook) with mock data to verify its appearance matches the design specifications. Check responsiveness on different screen sizes."
        },
        {
          "id": 4,
          "title": "Implement Styles for AI Response Bubbles",
          "description": "Create or refine the CSS styles or a styled-component for messages generated by Curi AI. This will ensure a consistent and distinct look for all AI-generated content, typically left-aligned with a neutral color.",
          "dependencies": [],
          "details": "Create a new CSS module (e.g., `AIResponse.module.css`) or styled-component. Define styles that contrast with the user message bubble. For example, `background-color: #F0F0F0;`, `align-self: flex-start;`. This component will receive the `content` prop.",
          "status": "pending",
          "testStrategy": "Render the new AI response component in isolation (e.g., in Storybook) to verify its appearance. Place it next to the user message component to ensure they are visually distinct."
        },
        {
          "id": 5,
          "title": "Integrate Styles and Perform End-to-End Verification",
          "description": "Connect the conditional logic from subtask #5 with the new styled components from subtasks #6 and #7. Verify in the live application that user messages and AI responses now render with their correct, distinct styles.",
          "dependencies": [],
          "details": "In the main message rendering component, replace any placeholder components with the newly styled `UserMessage` and `AIResponse` components. Pass the necessary props (message content, author name, etc.) to each based on the conditional logic.",
          "status": "pending",
          "testStrategy": "Launch the application and navigate to a chat screen. Send messages as a user and receive responses from the AI. Confirm that: 1. User messages have the user style. 2. AI messages have the AI style. 3. There are no styling regressions on other UI elements. 4. Check chat history to ensure old messages are also rendered correctly."
        }
      ]
    },
    {
      "id": 4,
      "title": "Add New Message Notifications in Room/All Tabs",
      "description": "The application does not provide any notification (e.g., a badge or dot) on the 'Room' or 'All' tabs when a new message is received, causing users to miss messages.",
      "details": "Implement a state management listener (e.g., using Redux, MobX, or React Context). When a new message is received via WebSocket, update a global state object that tracks unread messages per room. The UI components for the 'Room' and 'All' tabs should subscribe to this state and display a notification badge.",
      "testStrategy": "1. Be on the main screen, not inside a specific room. 2. Receive a new message from another user in a room. 3. Verify a notification badge with a count appears on the corresponding Room tab. 4. Enter the room. 5. Verify the badge disappears.",
      "priority": "high",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Setup State Management for Unread Message Counts",
          "description": "Create a new global state slice to manage the unread message counts for each room. This will be the central source of truth for all notification-related UI.",
          "dependencies": [],
          "details": "Using the existing state management library (e.g., Redux), create a new slice named 'notifications'. The state shape should be an object like `{ unreadCounts: { [roomId: string]: number } }`. Implement two reducers/actions: `incrementUnreadCount(roomId)` which increments the count for a given room, and `clearUnreadCount(roomId)` which resets the count for a room to 0.",
          "status": "pending",
          "testStrategy": "Write unit tests for the new reducers. Test that `incrementUnreadCount` correctly increases the count for a specific room ID and that `clearUnreadCount` resets it to zero without affecting other rooms."
        },
        {
          "id": 2,
          "title": "Integrate WebSocket Listener to Update Unread State",
          "description": "Modify the existing WebSocket message handler to update the unread message state when a new message arrives.",
          "dependencies": [],
          "details": "In the WebSocket service's `onMessage` event handler, after a message is received, get its `roomId`. Before processing the message, check if the user is currently active in that specific room. If they are not, dispatch the `incrementUnreadCount(roomId)` action created in the previous step. This requires access to the current route or active room ID within the WebSocket handler.",
          "status": "pending",
          "testStrategy": "Manually test by having the app open but not in a specific chat room. Send a message to that room from another client and use state inspection tools (e.g., Redux DevTools) to verify that the `unreadCounts` state for that room is incremented."
        },
        {
          "id": 3,
          "title": "Display Notification Badge on Individual Room List Items",
          "description": "Update the UI component that lists all chat rooms to display a notification badge next to any room that has unread messages.",
          "dependencies": [],
          "details": "In the component that renders the list of rooms (e.g., `RoomListItem`), use a selector to subscribe to the `notifications.unreadCounts` state. For each room being rendered, retrieve its unread count. If the count is greater than 0, conditionally render a visual indicator (e.g., a red dot or a badge with the count) next to the room's name.",
          "status": "pending",
          "testStrategy": "With the changes from the previous step, verify that when a message is received for a room, a badge appears next to it in the room list. Verify the badge does not show for other rooms."
        },
        {
          "id": 4,
          "title": "Display Aggregated Notification Badge on 'All' Tab",
          "description": "Update the main 'All' tab to show a single notification indicator if there are unread messages in any room.",
          "dependencies": [],
          "details": "In the main tab navigator component, create and use a memoized selector that computes whether there are any unread messages across all rooms (e.g., by checking if `Object.values(unreadCounts).some(count => count > 0)`). Use the result of this selector to conditionally render a notification dot on the 'All' tab icon or label.",
          "status": "pending",
          "testStrategy": "Verify that if any room has an unread message, a dot appears on the 'All' tab. Then, test that if all room notifications are cleared, the dot on the 'All' tab also disappears."
        },
        {
          "id": 5,
          "title": "Implement Logic to Clear Notifications on Room Entry",
          "description": "Add logic to clear the unread message count for a room when the user navigates into it, ensuring notifications are dismissed upon viewing.",
          "dependencies": [],
          "details": "In the component responsible for displaying a single chat room's content (e.g., `ChatRoomView`), use a `useEffect` hook. The effect should trigger when the component mounts or when its `roomId` prop changes. Inside this effect, dispatch the `clearUnreadCount(roomId)` action to reset the notification count for the currently viewed room.",
          "status": "pending",
          "testStrategy": "Navigate to a room with an unread notification badge. Verify that upon entering the room, the badge on the room list item disappears, and if it was the last room with unread messages, the badge on the 'All' tab also disappears."
        }
      ]
    },
    {
      "id": 5,
      "title": "Ensure Real-time Update of Profile Info in Private Space",
      "description": "In the private space, user profile pictures and names do not update in real-time within the 'Component after receiving message' and 'Invitation has been accepted by' components.",
      "details": "The components are likely fetching user data once and not subscribing to updates. Implement a WebSocket event or a similar real-time mechanism for user profile updates. When a user updates their profile, an event should be broadcast. The relevant UI components should listen for this event and re-fetch or update the user data in their state.",
      "testStrategy": "1. User A is in a private space with User B. 2. User B changes their profile picture and/or name on a different device. 3. Verify that User A's view of the private space components immediately updates to show User B's new picture and name without requiring a manual refresh.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Backend: Implement 'user_profile_updated' WebSocket Event",
          "description": "Define and implement a new WebSocket event on the server, `user_profile_updated`. This event should be triggered by the service responsible for handling user profile modifications (e.g., name or avatar changes).",
          "dependencies": [],
          "details": "The event should be emitted after the user's profile data has been successfully persisted to the database. The event payload must contain the `userId` of the updated user and a dictionary of the changed fields, such as `{ username: 'new_name', avatarUrl: 'new_url' }`.",
          "status": "pending",
          "testStrategy": "Write a unit test for the profile update service method. After calling the method, assert that a WebSocket event `user_profile_updated` is emitted with the correct `userId` and payload."
        },
        {
          "id": 2,
          "title": "Backend: Broadcast Event to Members of Shared Private Spaces",
          "description": "Integrate the broadcasting logic to ensure the `user_profile_updated` event is sent only to relevant clients. This means sending it to all users who are members of the same private space(s) as the user who updated their profile.",
          "dependencies": [
            1
          ],
          "details": "In the event emission logic, first retrieve all private space IDs associated with the `userId`. Then, iterate through these spaces and broadcast the event to all connected clients within each of those space's channels/rooms. This prevents broadcasting updates to disconnected or irrelevant users.",
          "status": "pending",
          "testStrategy": "Create an integration test with multiple simulated clients. Have Client A and Client B in Private Space 1, and Client C in Private Space 2. When Client A's profile is updated, verify that Client B receives the event, but Client C does not."
        },
        {
          "id": 3,
          "title": "Frontend: Establish a Centralized WebSocket Listener Service",
          "description": "Create or augment a global WebSocket manager/service on the frontend. This service will be responsible for handling the WebSocket connection and listening for incoming server-sent events, specifically the `user_profile_updated` event.",
          "dependencies": [
            2
          ],
          "details": "This service should be initialized once when the application loads. It should contain a message handler that parses incoming JSON messages, checks for an `event_type` key, and if it matches `user_profile_updated`, it should pass the event payload to the application's state management system.",
          "status": "pending",
          "testStrategy": "Using a mock WebSocket server, send a sample `user_profile_updated` message to the client. Assert that the listener service correctly identifies the event and calls the appropriate handler function with the payload."
        },
        {
          "id": 4,
          "title": "Frontend: Update Global State/Cache on Event Reception",
          "description": "Connect the WebSocket listener to the application's global state management system (e.g., Redux, Zustand, React Context). When the `user_profile_updated` event is received, dispatch an action to update the user's data in the central user cache/store.",
          "dependencies": [
            3
          ],
          "details": "Implement a new reducer or state update function that accepts the event payload (`userId` and updated fields). This function will find the corresponding user in the state (e.g., in a `usersById` map) and merge the new data. This ensures a single source of truth for user data.",
          "status": "pending",
          "testStrategy": "Write a unit test for the state management store. Dispatch a mock action containing the user update payload and assert that the user's data within the store is correctly updated."
        },
        {
          "id": 5,
          "title": "Frontend: Refactor UI Components to Use Reactive Global State",
          "description": "Refactor the 'Component after receiving message' and 'Invitation has been accepted by' components to source user profile data from the global state, making them reactive to the updates triggered by WebSocket events.",
          "dependencies": [
            4
          ],
          "details": "Remove any component-level data fetching logic (e.g., `useEffect` hooks that fetch user data on mount). Instead, use a selector (like Redux's `useSelector`) to pull the required user's name and avatar from the global store. The component will now automatically re-render whenever the underlying user data in the store changes.",
          "status": "pending",
          "testStrategy": "Perform an end-to-end manual test: Open two browser windows for two users in the same private space. Update one user's profile and verify the UI updates instantly in the other user's window. For automated testing, use React Testing Library to render the components with a mock store, simulate a store update, and assert that the component re-renders with the new data."
        }
      ]
    },
    {
      "id": 6,
      "title": "Correct Floating Button Visibility for Inviter",
      "description": "After an invitee accepts an invitation, the floating action button does not appear for the inviter until they leave and re-enter the room.",
      "details": "This is a state synchronization issue. The event `INVITE_ACCEPTED` should trigger a state update in the inviter's client that controls the visibility of the floating button. The component's visibility logic should be tied to a reactive state variable that is updated by the WebSocket event.",
      "testStrategy": "1. User A (inviter) invites User B to a room. 2. User A stays in the room view. 3. User B accepts the invitation. 4. Verify the floating button appears for User A immediately, without them having to leave and re-enter the room.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Trace and Log the `INVITE_ACCEPTED` WebSocket Event",
          "description": "To confirm the event is being received correctly by the inviter's client, locate the WebSocket event handler and add logging to capture the `INVITE_ACCEPTED` event and its payload.",
          "dependencies": [],
          "details": "Find the central WebSocket message handler in the client-side application. Add a `console.log` statement within the case/handler for the `INVITE_ACCEPTED` event type. The log should output the full event object to verify its structure and content upon an invitee's acceptance.",
          "status": "pending",
          "testStrategy": "Using two browser instances (one for inviter, one for invitee), send an invitation. Have the invitee accept it. Check the inviter's browser console for the log message and verify the payload is as expected."
        },
        {
          "id": 2,
          "title": "Create a New State Action/Mutation for Invite Status",
          "description": "Define the necessary state management logic (e.g., a Redux action and reducer, or a Zustand store update) to handle the data from the `INVITE_ACCEPTED` event and update the application's state accordingly.",
          "dependencies": [
            1
          ],
          "details": "In the relevant state store module for the room/session, create a new action (e.g., `setInviteAccepted`) that takes the event payload as an argument. This action should trigger a mutation/reducer that updates a specific state property, such as setting `room.isInviteFlowCompleted` to true or adding the new member to a `room.participants` array.",
          "status": "pending",
          "testStrategy": "Write a unit test for the new reducer/mutation to ensure it correctly modifies the state when the corresponding action is dispatched with a mock payload."
        },
        {
          "id": 3,
          "title": "Dispatch State Update from WebSocket Event Handler",
          "description": "Connect the WebSocket event handler to the state management system by dispatching the newly created action when an `INVITE_ACCEPTED` event is received.",
          "dependencies": [
            2
          ],
          "details": "In the WebSocket event handler modified in subtask 1, replace the `console.log` with a call to dispatch the `setInviteAccepted` action (created in subtask 2). Pass the relevant data from the event payload to the action.",
          "status": "pending",
          "testStrategy": "With the application running, repeat the test from subtask 1. Use browser developer tools (e.g., Redux DevTools) to confirm that the `setInviteAccepted` action is dispatched and that the application state is updated correctly in real-time."
        },
        {
          "id": 4,
          "title": "Bind Floating Button Visibility to the Reactive State",
          "description": "Modify the floating action button component to derive its visibility from the reactive state variable that is now being updated by the WebSocket event, instead of the initial room state.",
          "dependencies": [
            3
          ],
          "details": "Locate the UI component containing the floating action button. Change its visibility logic (e.g., the condition in a `v-if` or a React conditional render). It should now use a selector or hook to read the `room.isInviteFlowCompleted` (or equivalent) state property. The button should render when this state is true.",
          "status": "pending",
          "testStrategy": "After implementing the change, check that the floating button is initially hidden for the inviter. After the invitee accepts, verify the button appears immediately on the inviter's screen without any manual refresh or navigation."
        },
        {
          "id": 5,
          "title": "Perform End-to-End Test and Remove Diagnostic Code",
          "description": "Conduct a full end-to-end test of the invitation flow to ensure the fix works as expected and then remove any temporary logging or diagnostic code added during development.",
          "dependencies": [
            4
          ],
          "details": "Simulate the complete user journey: 1. Inviter opens the room and sends an invite. 2. Invitee receives and accepts the invite. 3. Confirm the floating button appears for the inviter instantly. 4. Confirm no regressions were introduced. Once verified, remove the `console.log` statement from the WebSocket handler (added in subtask 1).",
          "status": "pending",
          "testStrategy": "Manual end-to-end testing with two separate user accounts/sessions. An automated E2E test (e.g., using Cypress or Playwright) could also be written to simulate the two-user interaction and assert the button's visibility change."
        }
      ]
    },
    {
      "id": 7,
      "title": "Repair Message Search Functionality in Rooms",
      "description": "The search feature in rooms is not working correctly. It should filter the message list to show only messages containing the searched keyword(s).",
      "details": "Implement a client-side filtering mechanism. As the user types in the search bar, use the input value to filter the list of messages currently loaded in the chat view. The filtering should be case-insensitive. Pseudocode: `const filteredMessages = allMessages.filter(message => message.text.toLowerCase().includes(searchTerm.toLowerCase()));`",
      "testStrategy": "1. Open a room with a history of several messages. 2. Use the search bar and type a word that exists in some messages. 3. Verify that the message list updates to show ONLY the messages containing the search term. 4. Clear the search bar. 5. Verify that all messages are displayed again.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Connect Search Input to Component State",
          "description": "Capture the user's input from the search bar and store it in the local component state. This makes the search term available for the filtering logic.",
          "dependencies": [],
          "details": "In the main chat room component (e.g., `RoomView.js`), locate the search input element. If using React, use the `useState` hook to create a state variable, for example `const [searchTerm, setSearchTerm] = useState('');`. Attach an `onChange` event handler to the input field that calls `setSearchTerm` with the input's current value (`event.target.value`).",
          "status": "pending",
          "testStrategy": "Use browser developer tools (e.g., React DevTools) to inspect the component's state. Verify that as you type into the search bar, the `searchTerm` state variable updates in real-time."
        },
        {
          "id": 2,
          "title": "Implement Memoized Message Filtering Logic",
          "description": "Create the core filtering function that takes the full message list and the `searchTerm` from state, returning a new, filtered array of messages. The filtering must be case-insensitive.",
          "dependencies": [],
          "details": "Within the same component, use the `searchTerm` state. Create a new variable, `filteredMessages`. Apply the filter logic: `allMessages.filter(message => message.text.toLowerCase().includes(searchTerm.toLowerCase()))`. To optimize performance, wrap this entire operation in a `useMemo` hook, with `allMessages` and `searchTerm` as dependencies. This prevents re-filtering on every render.",
          "status": "pending",
          "testStrategy": "Write a unit test for the filtering logic. Create a mock array of message objects and test it with various search terms: a term that matches, a term with different casing, a partial term, and a term with no matches. Assert that the returned array is correct in each case."
        },
        {
          "id": 3,
          "title": "Render the Filtered Message List",
          "description": "Update the UI to display the `filteredMessages` array instead of the original, complete message list. The view should now dynamically update as the user types.",
          "dependencies": [],
          "details": "Locate the JSX where the message list is rendered (likely a `.map()` call on `allMessages`). Change this to map over the `filteredMessages` variable created in the previous step. No other changes to the rendering logic are needed, as it will now operate on the filtered data.",
          "status": "pending",
          "testStrategy": "Perform an end-to-end manual test. In the application, navigate to a chat room, type a known word from a visible message into the search bar, and confirm that the message list updates to show only the messages containing that word."
        },
        {
          "id": 4,
          "title": "Handle the 'No Results Found' State",
          "description": "Improve user experience by displaying a clear message when the search term does not match any messages in the list.",
          "dependencies": [],
          "details": "In the JSX, add a conditional check. If `searchTerm` has a value (is not an empty string) and `filteredMessages.length` is 0, render a placeholder component or a simple `<div>` with text like \"No results found\". Otherwise, render the message list as before.",
          "status": "pending",
          "testStrategy": "Manually test by typing a gibberish string into the search bar that is guaranteed not to be in any message. Verify that the standard message list disappears and the 'No results found' message is displayed instead."
        },
        {
          "id": 5,
          "title": "Ensure Search Clears Correctly",
          "description": "Ensure that when the search input is cleared (empty string), the message list reverts to showing all messages from the original, unfiltered list.",
          "dependencies": [],
          "details": "The filtering logic from subtask 9 should naturally handle this. When `searchTerm` is `''`, `message.text.toLowerCase().includes('')` returns `true` for all messages, so the original list is returned. This subtask is to verify this behavior and add an explicit clear button (e.g., an 'X' icon) to the search input that, when clicked, sets `searchTerm` to `''`.",
          "status": "pending",
          "testStrategy": "Manually test the flow: 1. Type a search term to filter the list. 2. Delete the text from the input manually. 3. Verify the full, original message list is restored. 4. If a clear button was added, repeat the process using the button."
        }
      ]
    },
    {
      "id": 8,
      "title": "Display Preview for AI-Tweaked Custom Replies",
      "description": "When a user creates a custom reply and the AI tweaks it, the application asks for confirmation but fails to show the preview of the AI-modified message.",
      "details": "The UI flow for AI-assisted replies needs to be corrected. After the AI returns the tweaked message, its content must be passed to a preview component (e.g., a modal or a specific UI area). The user should see the tweaked text and then be able to approve or reject it.",
      "testStrategy": "1. Initiate the 'add custom reply' flow. 2. Write a message and submit it for AI tweaking. 3. When the AI has processed it and asks for confirmation, verify that a preview of the new, AI-modified message text is clearly visible.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Create a Reusable `AITweakPreview` UI Component",
          "description": "Develop a new, self-contained UI component to display the AI-generated text. This component will serve as the preview area and will include action buttons for the user.",
          "dependencies": [],
          "details": "The component should accept `tweakedText` (string) as a prop to display the message. It must also accept `onApprove` and `onReject` (functions) as props for its action buttons. The component should render the text in a read-only format and include two buttons: 'Approve' and 'Reject'. Style it as a modal or an inline overlay that appears over the original text input.",
          "status": "pending",
          "testStrategy": "Use a component testing library like Storybook or Jest/React Testing Library. Create stories/tests to verify that the component renders the `tweakedText` prop correctly and that clicking the 'Approve' and 'Reject' buttons calls the respective `onApprove` and `onReject` callback props."
        },
        {
          "id": 2,
          "title": "Integrate the `AITweakPreview` Component into the Reply Creation View",
          "description": "Place the new `AITweakPreview` component into the existing custom reply creation screen. Its visibility will be controlled by the parent component's state.",
          "dependencies": [
            1
          ],
          "details": "Import the `AITweakPreview` component into the parent component responsible for handling custom replies. Add state management (e.g., `useState` hook) for `isPreviewVisible` (boolean, default false) and `tweakedReplyText` (string, default ''). Render the `AITweakPreview` component conditionally based on `isPreviewVisible`.",
          "status": "pending",
          "testStrategy": "In the browser, use developer tools to manually toggle the `isPreviewVisible` state variable to `true` and `false`. Confirm that the preview component appears and disappears correctly within the UI layout without breaking the page."
        },
        {
          "id": 3,
          "title": "Wire AI Service Response to the Preview Component",
          "description": "Modify the data flow so that when the AI service returns a tweaked message, its content is passed to the `AITweakPreview` component and the component is made visible.",
          "dependencies": [
            2
          ],
          "details": "Locate the existing API call that fetches the AI tweak. In the success handler (e.g., `.then()` or after `await`), update the parent component's state. Set `tweakedReplyText` with the message from the API response and set `isPreviewVisible` to `true`. Pass the `tweakedReplyText` state variable to the `AITweakPreview` component's `tweakedText` prop.",
          "status": "pending",
          "testStrategy": "Mock the API endpoint for the AI tweak. Trigger the action that calls this API. Verify that on receiving the mock response, the `AITweakPreview` component becomes visible and correctly displays the tweaked text from the mock data."
        },
        {
          "id": 4,
          "title": "Implement 'Approve' Button Logic",
          "description": "Connect the 'Approve' button's `onApprove` callback to a handler function that accepts the AI-tweaked text and closes the preview.",
          "dependencies": [
            3
          ],
          "details": "In the parent component, create a handler function, e.g., `handleApprove()`. This function should update the main custom reply input field's value with the `tweakedReplyText` from the state. Afterwards, it should reset the preview state by setting `isPreviewVisible` to `false`. Pass this `handleApprove` function to the `AITweakPreview` component's `onApprove` prop.",
          "status": "pending",
          "testStrategy": "With the preview visible, click the 'Approve' button. Verify that the main text input for the custom reply is updated with the AI-tweaked text and the preview component disappears. Check that the component state is correctly reset."
        },
        {
          "id": 5,
          "title": "Implement 'Reject' Button Logic",
          "description": "Connect the 'Reject' button's `onReject` callback to a handler function that discards the AI tweak and closes the preview.",
          "dependencies": [
            3
          ],
          "details": "In the parent component, create a handler function, e.g., `handleReject()`. This function should only reset the preview state by setting `isPreviewVisible` to `false` and clearing the `tweakedReplyText` state variable. It should not modify the user's original text in the main input field. Pass this `handleReject` function to the `AITweakPreview` component's `onReject` prop.",
          "status": "pending",
          "testStrategy": "With the preview visible, click the 'Reject' button. Verify that the preview component disappears and that the text in the main custom reply input field remains unchanged (i.e., it's still the user's original text)."
        }
      ]
    },
    {
      "id": 9,
      "title": "[iOS] Fix Search Bar Background Transparency",
      "description": "On iOS devices, the background of the search bar in rooms becomes transparent while the user is typing, which is visually jarring.",
      "details": "This is likely a CSS or view controller configuration issue specific to iOS. Inspect the styling applied to the search bar component. Ensure that its background color property is set and not being overridden or set to transparent during its 'editing' or 'active' state.",
      "testStrategy": "1. Using an iOS device or simulator, navigate to a room's search bar. 2. Tap on the search bar and begin typing. 3. Verify the search bar's grey background remains opaque and does not become transparent.",
      "priority": "low",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Reproduce Issue and Inspect View Hierarchy",
          "description": "First, reliably reproduce the transparency issue on an iOS simulator or device. While the search bar is active and transparent, pause the app and use Xcode's 'Debug View Hierarchy' tool to inspect the search bar's view components. Identify the specific view (e.g., `_UISearchBarSearchFieldBackgroundView`, `UITextField`) that is losing its background color.",
          "dependencies": [],
          "details": "Focus on the properties of the search bar and its subviews in the View Debugger. Check the `backgroundColor`, `alpha`, `isOpaque`, and `backgroundImage` properties for the search bar and its internal text field. Note the class names of the relevant views for the next step.",
          "status": "pending",
          "testStrategy": "Manually trigger the search bar by tapping on it and typing. Confirm that the background becomes transparent. Use the View Debugger to capture the state."
        },
        {
          "id": 2,
          "title": "Isolate the Code Causing the Transparency",
          "description": "Based on the view hierarchy inspection, search the codebase for where the search bar's appearance is configured. Check the relevant view controller's `viewDidLoad` or `viewWillAppear` methods, any `UISearchBarDelegate` methods (especially `searchBarTextDidBeginEditing:`), and any custom `UISearchBar` subclasses or extensions. Pinpoint the code that sets or unsets the background style.",
          "dependencies": [],
          "details": "Look for lines of code that set `backgroundColor` to `.clear` or `nil`. Also, check for modifications to `searchBarStyle`, `barTintColor`, or `backgroundImage`. Place breakpoints in these locations to confirm they are being executed when the search bar becomes active.",
          "status": "pending",
          "testStrategy": "Use breakpoints to trace the execution flow when the search bar is tapped. Verify which piece of code is responsible for altering the background."
        },
        {
          "id": 3,
          "title": "Implement Fix by Setting a Stable Background Color",
          "description": "Implement a fix to ensure the search bar's background color remains consistent. The most direct approach is to explicitly set the background color of the search bar's internal text field.",
          "dependencies": [],
          "details": "In the view controller where the search bar is configured, access the search text field and set its background color. For example: `searchController.searchBar.searchTextField.backgroundColor = .white`. This should be done after the search bar is initialized.",
          "status": "pending",
          "testStrategy": "After applying the code change, run the app and activate the search bar. The background of the text input area should now remain the color you set and not become transparent."
        },
        {
          "id": 4,
          "title": "Ensure Container View Consistency",
          "description": "Sometimes, the container of the search text field can also be transparent. To prevent this, ensure the search bar's main `barTintColor` is also set and that there is no transparent background image being applied.",
          "dependencies": [],
          "details": "Set the `barTintColor` property on the `UISearchBar` to match the desired background color. To override any system default styling that might cause transparency, also set the background image to a single-pixel image of the desired color: `searchController.searchBar.backgroundImage = UIImage()`. This combination ensures the entire component has a solid background.",
          "status": "pending",
          "testStrategy": "Visually inspect the entire search bar component, not just the text field. Ensure there are no transparent gaps or borders around the text field when it is active or inactive."
        },
        {
          "id": 5,
          "title": "Verify Fix Across States and iOS Versions",
          "description": "Perform final verification to confirm the fix works correctly and hasn't introduced any visual regressions. Test the search bar in all its states: inactive, active (editing), and with text entered.",
          "dependencies": [],
          "details": "Run the app on simulators for different iOS versions (e.g., latest and one major version back). Test in both Light Mode and Dark Mode to ensure the color is appropriate for both themes. Confirm that the search bar's appearance is correct and stable throughout the user interaction.",
          "status": "pending",
          "testStrategy": "Create a testing checklist: 1. Tap search bar -> background is solid. 2. Type text -> background is solid. 3. Clear text -> background is solid. 4. Dismiss keyboard -> background is solid. 5. Repeat for Light/Dark mode. 6. Repeat on at least two different iOS version simulators."
        }
      ]
    },
    {
      "id": 10,
      "title": "[iOS] Correct Participant Placeholder Image to be Circular",
      "description": "On iOS devices, the placeholder image for room participants is incorrectly displayed as an oval instead of a circle.",
      "details": "This is a styling issue. The component displaying the placeholder image needs to have its `border-radius` set to `50%` to ensure it is a perfect circle. Also, ensure the image view itself has an equal width and height. For native iOS, this involves setting the `cornerRadius` of the `UIImageView`'s layer to be half of its width.",
      "testStrategy": "1. Using an iOS device or simulator, view the room indicator or participant list. 2. Find a participant who is using a placeholder image. 3. Verify the placeholder is a perfect circle, not an oval.",
      "priority": "low",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Identify and Isolate the Participant Placeholder UIImageView",
          "description": "Locate the specific UIView or UIImageView subclass and its corresponding layout file (XIB, Storyboard, or programmatic code) that is responsible for rendering the participant placeholder image.",
          "dependencies": [],
          "details": "Use Xcode's View Debugger on a running simulator or device to inspect the view hierarchy and identify the class name of the oval view. Search the codebase for this class name to find its implementation file. This is the component that will be modified.",
          "status": "pending",
          "testStrategy": "Confirm the correct file has been located by temporarily changing the background color of the identified view (e.g., to `UIColor.red`) and verifying the change appears on the participant placeholder in the running application."
        },
        {
          "id": 2,
          "title": "Enforce 1:1 Aspect Ratio Constraint on the Placeholder View",
          "description": "To ensure a perfect circle, the view must first be a perfect square. Apply constraints or frame logic to enforce an equal width and height for the placeholder view.",
          "dependencies": [],
          "details": "If using Auto Layout, add a new constraint programmatically or in Interface Builder that sets the view's width equal to its height. If using frame-based layout, ensure the width and height are set to the same value during layout calculations.",
          "status": "pending",
          "testStrategy": "Run the app and use the View Debugger to inspect the view's frame. Verify that its width and height properties are identical. The view should now appear as a square-shaped oval."
        },
        {
          "id": 3,
          "title": "Apply Dynamic Corner Radius and Clip to Bounds",
          "description": "Programmatically set the `cornerRadius` of the view's layer to be half of its width, which will create the circular shape. The contents must also be clipped to this new circular boundary.",
          "dependencies": [],
          "details": "In the `layoutSubviews()` method of the view's class, set `layer.cornerRadius = bounds.width / 2`. This ensures the radius is always correct even if the view's size changes. Also, set `layer.masksToBounds = true` (or `clipsToBounds = true` on the view itself) to clip the image content to the circular shape.",
          "status": "pending",
          "testStrategy": "Run the app and visually confirm that the placeholder is now a perfect circle. Test on different device sizes (e.g., iPhone SE vs. iPhone Pro Max) and orientations to ensure the dynamic calculation works correctly."
        },
        {
          "id": 4,
          "title": "Verify Circular Placeholder in All Relevant UI Contexts",
          "description": "The participant placeholder may be used in multiple screens or states (e.g., main grid view, speaker-focused view, participant list). Verify that the fix is applied correctly in all instances and has not introduced visual regressions.",
          "dependencies": [],
          "details": "Navigate through the application to all screens where participant avatars are displayed. Pay special attention to layouts with different numbers of participants, which might use different cell sizes for the placeholder.",
          "status": "pending",
          "testStrategy": "Create a checklist of all screens/views where the component is used. Go through the checklist and confirm the placeholder is circular in each one. Take screenshots for the pull request."
        },
        {
          "id": 5,
          "title": "Finalize Code, Add Comments, and Create Pull Request",
          "description": "Clean up any temporary or debugging code, add comments explaining the dynamic `cornerRadius` calculation in `layoutSubviews`, and submit a Pull Request for review.",
          "dependencies": [],
          "details": "Ensure the code adheres to the project's style guide. The PR description should clearly state the problem (oval placeholder) and the solution (enforcing a square aspect ratio and setting `cornerRadius` dynamically). Link to the parent task (ID: 10).",
          "status": "pending",
          "testStrategy": "The pull request should be reviewed by at least one other iOS developer. The reviewer should pull the branch and perform the verification steps from subtask 14 to confirm the fix."
        }
      ]
    },
    {
      "id": 11,
      "title": "Resolve Scrolling Issue in Select Participant Component",
      "description": "There is an unspecified scrolling issue within the 'select participant' component, which likely hinders the user's ability to see and select from a long list of participants.",
      "details": "Inspect the CSS and structure of the participant list container. Ensure it has `overflow-y: auto;` or `overflow-y: scroll;` and a defined `max-height`. If the component is virtualized, debug the virtualization library's configuration.",
      "testStrategy": "1. Navigate to the 'select participant' component in a scenario with more participants than can fit on the screen. 2. Attempt to scroll through the list. 3. Verify that the list scrolls smoothly and all participants can be reached and selected.",
      "priority": "low",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Reproduce and Diagnose the Scrolling Issue in a Test Environment",
          "description": "First, reliably reproduce the reported scrolling issue. This involves populating the 'select participant' component with a sufficient number of items to necessitate scrolling and then using browser developer tools to inspect the relevant elements and their computed styles.",
          "dependencies": [],
          "details": "Create a story in Storybook or a dedicated test page. Populate the participant list with at least 50-100 mock items. Open the component and attempt to scroll. Use the browser's inspector to identify the primary list container and examine its CSS properties like `height`, `max-height`, `overflow`, and `position`. Note any parent elements that might have `overflow: hidden`.",
          "status": "pending",
          "testStrategy": "Manual verification: Confirm that with a large dataset, the list is cut off and the scrollbar is either missing or non-functional. This confirms the bug is reproducible."
        },
        {
          "id": 2,
          "title": "Implement CSS Fix for Container Overflow and Height",
          "description": "Apply the most common fix by ensuring the participant list container has the correct CSS properties to enable vertical scrolling. This involves setting a maximum height and defining the overflow behavior.",
          "dependencies": [],
          "details": "In the component's dedicated CSS/SCSS file, target the list container element identified in the previous step. Add or modify its style rules to include `overflow-y: auto;` and `max-height: 300px;` (or another appropriate value). Use `!important` only as a last resort if you suspect style overrides, and then investigate the source of the override.",
          "status": "pending",
          "testStrategy": "With the large dataset from the previous task, verify that a vertical scrollbar now appears and is fully functional. Also, test with a small dataset (e.g., 3 items) to ensure no scrollbar appears unnecessarily."
        },
        {
          "id": 3,
          "title": "Investigate and Correct Virtualization Library Configuration",
          "description": "If a simple CSS fix does not resolve the issue, investigate the configuration of the virtualization library (e.g., react-window, react-virtualized) being used. Incorrect height/width props are a common cause of scrolling failures in virtualized lists.",
          "dependencies": [],
          "details": "This task is only necessary if the issue persists after subtask 13. Check the component's source code for a virtualization library. Review the props being passed to the virtual list component, especially `height`, `itemSize`, and `itemCount`. Ensure these are being calculated correctly. The container holding the virtualized list often needs `height: 100%` and its parent must have a fixed height.",
          "status": "pending",
          "testStrategy": "Use React DevTools to inspect the props passed to the virtualized component. Try hardcoding the `height` and `itemSize` props to see if it resolves the issue. If it does, the problem lies in how those values are being dynamically calculated."
        },
        {
          "id": 4,
          "title": "Refactor Parent DOM Structure and Styles",
          "description": "If the issue is not with the list element itself or a virtualization library, analyze and refactor the parent component's structure. An ancestor element may be improperly constraining the list container, preventing it from scrolling.",
          "dependencies": [],
          "details": "This is an alternative path if subtask 14 is not applicable. Using the browser inspector, examine the parent elements of the list. Look for any ancestor with `overflow: hidden`. Also, check the flexbox or grid properties of the direct parent. The parent might need `display: flex; flex-direction: column;` and the list container might need `flex-grow: 1;` and `min-height: 0;` to scroll correctly within a flex layout.",
          "status": "pending",
          "testStrategy": "After refactoring the structure, re-run the manual tests from subtask 13. Ensure the fix works and has not introduced any visual regressions or layout shifts in other parts of the component or page."
        },
        {
          "id": 5,
          "title": "Final Verification and Cross-Browser Testing",
          "description": "After applying a fix from the previous steps, perform a final, comprehensive verification. This includes testing edge cases and ensuring the solution is robust across all supported web browsers.",
          "dependencies": [],
          "details": "Test the following scenarios: 1) List with zero items. 2) List with few items (no scrollbar). 3) List with many items (scrollbar works). 4) Selecting an item from the bottom of the scrolled list. Perform these tests on the latest versions of Chrome, Firefox, and Safari to ensure consistent behavior and appearance.",
          "status": "pending",
          "testStrategy": "An automated end-to-end test using Cypress or Playwright should be created. The test will mount the component with a long list, scroll to the bottom of the list using a command like `cy.get('.participant-list').scrollTo('bottom')`, and then assert that the last item in the list is visible."
        }
      ]
    },
    {
      "id": 12,
      "title": "Correct Poll Feedback Input Field Behavior",
      "description": "The text input field for poll feedback is open by default, before the user has interacted with the poll. It should only become available after a poll option is selected or a feedback button is pressed.",
      "details": "The visibility or enabled state of the text input should be controlled by the poll's state. Initially, the input should be hidden or disabled. An `onClick` handler on the poll options/feedback button should update the state to make the text input visible/enabled.",
      "testStrategy": "1. View a poll. 2. Verify that the text input field for feedback is not visible or is disabled. 3. Select an option in the poll. 4. Verify that the text input field now becomes visible and usable.",
      "priority": "low",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Introduce State for Feedback Input Visibility",
          "description": "In the parent poll component, add a new boolean state variable to manage the visibility or enabled status of the feedback text input. This state should be initialized to `false` to ensure the input is hidden by default.",
          "dependencies": [],
          "details": "In the main React component managing the poll (e.g., `Poll.js`), use the `useState` hook to create a new state variable: `const [isFeedbackInputVisible, setFeedbackInputVisible] = useState(false);`. This will serve as the single source of truth for the input's visibility.",
          "status": "pending",
          "testStrategy": "Using React DevTools, inspect the poll component upon initial load and verify that the `isFeedbackInputVisible` state is present and set to `false`."
        },
        {
          "id": 2,
          "title": "Update Poll Option Handler to Reveal Input",
          "description": "Modify the `onClick` event handler for the poll options. When a user selects an option, the handler should update the visibility state to `true`, causing the feedback input to appear.",
          "dependencies": [],
          "details": "Locate the function that handles a user's vote (e.g., `handleVote(optionId)`). Within this function, add a call to `setFeedbackInputVisible(true)`. This ensures that after voting, the user is immediately able to provide textual feedback.",
          "status": "pending",
          "testStrategy": "Click on any poll option. Verify using React DevTools that the `isFeedbackInputVisible` state transitions from `false` to `true`. The UI should not yet change, as that is handled in a subsequent task."
        },
        {
          "id": 3,
          "title": "Connect Feedback Button to Reveal Input",
          "description": "Wire up the `onClick` handler for any dedicated 'Add Feedback' or similar button to also set the visibility state to `true`. This provides an alternative path for the user to open the feedback input without voting first.",
          "dependencies": [],
          "details": "Find the dedicated feedback button element. In its `onClick` prop, call a function that executes `setFeedbackInputVisible(true)`. If no such button exists, this task can be to create one.",
          "status": "pending",
          "testStrategy": "Click the dedicated feedback button. Verify using React DevTools that the `isFeedbackInputVisible` state transitions from `false` to `true`."
        },
        {
          "id": 4,
          "title": "Conditionally Render the Feedback Input Field",
          "description": "Modify the JSX to use the `isFeedbackInputVisible` state to control whether the feedback input field is rendered in the DOM or if its `disabled` attribute is set.",
          "dependencies": [],
          "details": "Pass the `isFeedbackInputVisible` state down to the feedback input component. The preferred implementation is to use conditional rendering: `{isFeedbackInputVisible && <FeedbackInputField />}`. Alternatively, you can control its `disabled` property: `<FeedbackInputField disabled={!isFeedbackInputVisible} />`.",
          "status": "pending",
          "testStrategy": "1. Load the page and confirm the feedback input is not visible/is disabled. 2. Click a poll option and confirm the input becomes visible and enabled. 3. Reload, click the dedicated feedback button, and confirm the input becomes visible and enabled."
        },
        {
          "id": 5,
          "title": "Auto-Focus the Input Field When It Appears",
          "description": "Enhance the user experience by automatically setting focus on the feedback text input as soon as it becomes visible, allowing the user to start typing immediately.",
          "dependencies": [],
          "details": "Create a ref for the input element using `useRef`: `const inputRef = useRef(null);`. Then, use a `useEffect` hook that listens for changes to `isFeedbackInputVisible`. Inside the effect, add a condition: `if (isFeedbackInputVisible) { inputRef.current?.focus(); }`.",
          "status": "pending",
          "testStrategy": "Click a poll option or the feedback button. Verify that the feedback input not only appears but that the text cursor is immediately active inside it without requiring an extra click."
        }
      ]
    },
    {
      "id": 13,
      "title": "Verify and Correct 'Done' Button Behavior in Ground Rules",
      "description": "The 'Done' button in the ground rules component closes the component and sends the rules as a message. This behavior needs to be confirmed as intended, and if not, corrected.",
      "details": "First, consult with the Product Manager or UX designer to confirm the intended behavior. If the current behavior is incorrect, modify the `onClick` handler for the 'Done' button to only dismiss the component without sending any message.",
      "testStrategy": "1. Open the 'Ground rules and agreement' component. 2. Click the 'Done' button. 3. Verify that the component disappears. 4. Verify that NO message containing the rules is sent to the private space.",
      "priority": "low",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Confirm 'Done' Button's Intended Behavior with Product/UX",
          "description": "Consult with the Product Manager and/or UX designer to get a definitive specification for the 'Done' button's behavior in the ground rules component. The primary question is whether it should send a message or only dismiss the view.",
          "dependencies": [],
          "details": "Contact the relevant stakeholders (Product/UX) and ask for clarification on the user story. Document the confirmed behavior in the parent task's comments for future reference. This decision will dictate whether subsequent coding tasks are necessary.",
          "status": "pending",
          "testStrategy": "Confirmation is achieved when the decision is documented and agreed upon by the product owner."
        },
        {
          "id": 2,
          "title": "Locate Ground Rules Component and 'onClick' Handler",
          "description": "Investigate the frontend codebase to identify the specific React/Vue/Angular component file for the ground rules view and locate the 'Done' button element and its associated `onClick` event handler function.",
          "dependencies": [],
          "details": "Search the codebase for component names like `GroundRules`, `RulesModal`, or similar. Once the component is found, inspect its template/JSX to find the 'Done' button. Trace its click event listener to the function that executes when the button is pressed. This function is the target for modification.",
          "status": "pending",
          "testStrategy": "Add a temporary `console.log('Handler found')` to the identified function. Run the application, click the button, and verify the message appears in the browser's developer console."
        },
        {
          "id": 3,
          "title": "Modify Handler to Remove Message-Sending Logic",
          "description": "If the confirmed behavior is to only dismiss the component, modify the 'Done' button's `onClick` handler to remove the function call that sends the ground rules as a message.",
          "dependencies": [],
          "details": "In the handler function identified in the previous step, locate the specific line(s) of code that dispatch an action, call an API, or otherwise trigger the message-sending event. Comment out or delete this logic, leaving only the component dismissal logic.",
          "status": "pending",
          "testStrategy": "Use browser developer tools to monitor network requests and/or state management (e.g., Redux DevTools). After the change, click the 'Done' button and confirm that no message-sending API call or action is dispatched."
        },
        {
          "id": 4,
          "title": "Ensure Component Dismissal Logic Remains Functional",
          "description": "Verify that the logic responsible for closing or hiding the ground rules component is still present and functions correctly after the changes to the `onClick` handler.",
          "dependencies": [],
          "details": "The `onClick` handler should still contain the code that updates the component's visibility state (e.g., calling a `setState` function like `setVisible(false)` or dispatching a UI state action). Ensure this part of the function was not accidentally removed or broken during the modification.",
          "status": "pending",
          "testStrategy": "After implementing the changes, run the application locally. Click the 'Done' button and visually confirm that the ground rules component closes as expected."
        },
        {
          "id": 5,
          "title": "End-to-End Test of the Corrected Ground Rules Flow",
          "description": "Perform a complete manual test of the ground rules feature to verify the corrected behavior and check for any regressions in the component's lifecycle.",
          "dependencies": [],
          "details": "The test should cover the full user flow: 1. Open the ground rules component. 2. Click the 'Done' button. 3. Verify the component closes. 4. Check the chat/message view to confirm NO new message was sent. 5. Attempt to open the ground rules component again to ensure it still works.",
          "status": "pending",
          "testStrategy": "Execute a manual test case that follows the steps in the details. The test passes if the component closes, no message is sent, and the component can be reopened without issue."
        }
      ]
    }
  ]
}